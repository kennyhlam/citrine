#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math

mult_div = '/*'
l_paren = '('
r_paren = ')'
def parse(units):
    '''
        Input:
            (str) units - which is a string representing units (may be
                multipled, divided, or have parenthesis)

        Returns an array representing the expression of the units
        If there exist parenthesis, each set of parens nests
        another array representing the enclosed expression.

        ex.     'a/b'   => ['a', '/', 'b']
            'a/(b*c)    => ['a', '/', ['b', '*', 'c']]
    '''
    expr_array = []
    unit = ''
    idx = 0

    while idx < len(units):
        ch = units[idx]

        # ran across a parenthetical expression
        # grab the entire paren expr and recurse
        # move index by the paren expr length + 2 (left and right parens each add one)
        if ch == l_paren:
            parend_expr = units[idx+1:].partition(r_paren)[0]
            sub_expr = parse(parend_expr)
            expr_array.append(sub_expr)
            idx += len(parend_expr) + 2
        
        # ran across multiplcation or division
        # end the previous unit if it existed, add in this operation, start blank unit
        elif ch in mult_div:
            if len(unit) > 0:
                expr_array.append(unit)
            expr_array.append(ch)
            unit = ''
            idx += 1
        
        # part of some character string representing a unit
        # just continue to next character
        else:
            unit += ch
            idx += 1

    if len(unit) > 0:
        expr_array.append(unit)

    return expr_array

def get_value(expr):
    '''
        Input
            (array) expr - an expression array generated by the parse method

        Returns a tuple of (conversion, units), where:
            - (float) conversion is the multiplication factor to convert units to SI
            - (array) units is an expression array matching the input expr
    '''

    if type(expr) == str or type(expr) == unicode:
        return convert_to_si(expr)
    elif type(expr) == list:
        div = lambda x, y: x/y
        mult = lambda x, y: x*y

        l_operand = get_value(expr[0])
        units = [l_operand[1]]
        conversion = l_operand[0]

        for i in xrange(1, len(expr)-1, 2):
            op = expr[i]
            r_operand = get_value(expr[i+1])

            if op == '/':
                units.append('/')
                units.append(r_operand[1])
                conversion = div(conversion, r_operand[0])
            elif op == '*':
                units.append('*')
                units.append(r_operand[1])
                conversion = mult(conversion, r_operand[0])
            else:
                raise RuntimeError(u"Unknown operation: {}".format(op))

    else:
        raise RuntimeError(u'Cannot determine value of {} with type {}.'.format(expr, type(expr)))

    return (conversion, units)

si_conversion = {
    'minute': (60.0, 's'),
    'min': (60.0, 's'),
    'hour': (3600.0, 's'),
    'h': (3600.0, 's'),
    'day': (86400.0, 's'),
    'd': (86400.0, 's'),
    'degree': (math.pi/180.0, 'rad'),
    u'Â°': (math.pi/180.0, 'rad'),
    "'": (math.pi/180.0, 'rad'),
    'second': (math.pi/648000.0, 'rad'),
    '"': (math.pi/648000.0, 'rad'),
    'hectare': (10000.0, 'm2'),
    'ha': (10000.0, 'm2'),
    'litre': (.001, 'm3'),
    'L': (.001, 'm3'),
    'tonne': (1000.0, 'kg'),
    't': (1000.0, 'kg')
}
def convert_to_si(base_unit):
    '''
        Input
            (str) base_unit - a non-SI unit

        Returns a tuple of (conversion, units), where:
            - (float) conversion is the multiplication factor to convert units to SI
            - (array) units is an expression array matching the input expr
        Really just lookup table
    '''
    return si_conversion[base_unit]


def stringify_expr(expr):
    '''
        Input
            (array) expr - an expression array following the layout from parse

        Returns a string of the expr flattened
    '''
    s = u''
    for entry in expr:
        if type(entry) == str:
            s += entry
        elif type(entry) == list:
            s += '(' + stringify_expr(entry) + ')'
        else:
            raise RuntimeError(u"Unable to stringify element: {}".format(entry))
    return s
